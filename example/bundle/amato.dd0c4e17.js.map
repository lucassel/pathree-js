{"mappings":"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","sources":["node_modules/three/examples/jsm/loaders/RGBELoader.js","src/index.js","src/core/PathTracingRenderer.js","src/materials/BlendMaterial.js","src/core/DynamicPathTracingSceneGenerator.js","src/core/MaterialReducer.js","src/core/PhysicalCamera.js","src/core/EquirectCamera.js","src/utils/BlurredEnvMapGenerator.js","src/materials/PhysicalPathTracingMaterial.js","src/uniforms/MaterialsTexture.js","src/uniforms/RenderTarget2DArray.js","src/shader/shaderMaterialSampling.js","src/shader/shaderGGXFunctions.js","src/shader/shaderEnvMapSampling.js","src/shader/shaderLightSampling.js","src/uniforms/PhysicalCameraUniform.js","src/uniforms/EquirectHdrInfoUniform.js","src/uniforms/LightsTexture.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearEncoding,\n\tLinearFilter\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* return codes for rgbe routines */\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\n\t\t\tRGBE_RETURN_FAILURE = - 1,\n\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn RGBE_RETURN_FAILURE;\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\n\n\t\t\tconst w = rgbe_header_info.width,\n\t\t\t\th = rgbe_header_info.height,\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\n\n\t\t\t\tlet data, type;\n\t\t\t\tlet numElements;\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = floatArray;\n\t\t\t\t\t\ttype = FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = halfArray;\n\t\t\t\t\t\ttype = HalfFloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: w, height: h,\n\t\t\t\t\tdata: data,\n\t\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\t\ttype: type\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\t\t\t\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","// core\nexport * from './core/PathTracingRenderer.js';\nexport * from './core/PathTracingSceneGenerator.js';\nexport * from './core/DynamicPathTracingSceneGenerator.js';\nexport * from './core/MaterialReducer.js';\nexport * from './core/PhysicalCamera.js';\nexport * from './core/EquirectCamera.js';\n\n// uniforms\nexport * from './uniforms/MaterialsTexture.js';\nexport * from './uniforms/RenderTarget2DArray.js';\nexport * from './uniforms/EquirectHdrInfoUniform.js';\nexport * from './uniforms/PhysicalCameraUniform.js';\n\n// utils\nexport * from './utils/GeometryPreparationUtils.js';\nexport * from './utils/BlurredEnvMapGenerator.js';\n\n// materials\nexport * from './materials/MaterialBase.js';\nexport * from './materials/PhysicalPathTracingMaterial.js';\n\n// shaders\nexport * from './shader/shaderMaterialSampling.js';\nexport * from './shader/shaderUtils.js';\nexport * from './shader/shaderStructs.js';\n","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { BlendMaterial } from '../materials/BlendMaterial.js';\n\nfunction* renderTask() {\n\n\tconst {\n\t\t_renderer,\n\t\t_fsQuad,\n\t\t_blendQuad,\n\t\t_primaryTarget,\n\t\t_blendTargets,\n\t\talpha,\n\t\tcamera,\n\t\tmaterial,\n\t} = this;\n\n\tconst blendMaterial = _blendQuad.material;\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\n\n\twhile ( true ) {\n\n\t\tif ( alpha ) {\n\n\t\t\tblendMaterial.opacity = 1 / ( this.samples + 1 );\n\t\t\tmaterial.blending = NoBlending;\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = 1 / ( this.samples + 1 );\n\t\t\tmaterial.blending = NormalBlending;\n\n\t\t}\n\n\t\tconst w = _primaryTarget.width;\n\t\tconst h = _primaryTarget.height;\n\t\tmaterial.resolution.set( w, h );\n\t\tmaterial.seed ++;\n\n\t\tconst tx = this.tiles.x || 1;\n\t\tconst ty = this.tiles.y || 1;\n\t\tconst totalTiles = tx * ty;\n\t\tconst dprInv = ( 1 / _renderer.getPixelRatio() );\n\t\tfor ( let y = 0; y < ty; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < tx; x ++ ) {\n\n\t\t\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\n\t\t\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\n\n\t\t\t\t// Perspective camera (default)\n\t\t\t\tlet cameraType = 0;\n\n\t\t\t\t// An orthographic projection matrix will always have the bottom right element == 1\n\t\t\t\t// And a perspective projection matrix will always have the bottom right element == 0\n\t\t\t\tif ( camera.projectionMatrix.elements[ 15 ] > 0 ) {\n\n\t\t\t\t\t// Orthographic\n\t\t\t\t\tcameraType = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( camera.isEquirectCamera ) {\n\n\t\t\t\t\t// Equirectangular\n\t\t\t\t\tcameraType = 2;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.setDefine( 'CAMERA_TYPE', cameraType );\n\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\n\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t\t\t_renderer.setScissorTest( true );\n\t\t\t\t_renderer.setScissor(\n\t\t\t\t\tdprInv * Math.ceil( x * w / tx ),\n\t\t\t\t\tdprInv * Math.ceil( ( ty - y - 1 ) * h / ty ),\n\t\t\t\t\tdprInv * Math.ceil( w / tx ),\n\t\t\t\t\tdprInv * Math.ceil( h / ty ) );\n\t\t\t\t_renderer.autoClear = false;\n\t\t\t\t_fsQuad.render( _renderer );\n\n\t\t\t\t_renderer.setScissorTest( false );\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\t\t\t\t_renderer.autoClear = ogAutoClear;\n\n\t\t\t\tif ( alpha ) {\n\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\n\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\n\t\t\t\t\t_blendQuad.render( _renderer );\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tthis.samples += ( 1 / totalTiles );\n\n\t\t\t\tyield;\n\n\t\t\t}\n\n\t\t}\n\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\n\n\t\tthis.samples = Math.round( this.samples );\n\n\t}\n\n}\n\nconst ogClearColor = new Color();\nexport class PathTracingRenderer {\n\n\tget material() {\n\n\t\treturn this._fsQuad.material;\n\n\t}\n\n\tset material( v ) {\n\n\t\tthis._fsQuad.material = v;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\n\n\t}\n\n\tset alpha( v ) {\n\n\t\tif ( ! v ) {\n\n\t\t\tthis._blendTargets[ 0 ].dispose();\n\t\t\tthis._blendTargets[ 1 ].dispose();\n\n\t\t}\n\n\t\tthis._alpha = v;\n\t\tthis.reset();\n\n\t}\n\n\tget alpha() {\n\n\t\treturn this._alpha;\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\tthis.camera = null;\n\t\tthis.tiles = new Vector2( 1, 1 );\n\n\t\tthis.samples = 0;\n\t\tthis.stableNoise = false;\n\t\tthis._renderer = renderer;\n\t\tthis._alpha = false;\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\n\t\tthis._task = null;\n\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: FloatType,\n\t\t} );\n\t\tthis._blendTargets = [\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t} ),\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t} ),\n\t\t];\n\n\t}\n\n\tsetSize( w, h ) {\n\n\t\tthis._primaryTarget.setSize( w, h );\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\n\t\tthis.reset();\n\n\t}\n\n\tdispose() {\n\n\t\tthis._primaryTarget.dispose();\n\t\tthis._blendTargets[ 0 ].dispose();\n\t\tthis._blendTargets[ 1 ].dispose();\n\n\t\tthis._fsQuad.dispose();\n\t\tthis._blendQuad.dispose();\n\t\tthis._task = null;\n\n\t}\n\n\treset() {\n\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.getClearColor( ogClearColor );\n\n\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\n\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\tthis.samples = 0;\n\t\tthis._task = null;\n\n\t\tif ( this.stableNoise ) {\n\n\t\t\tthis.material.seed = 0;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tif ( ! this._task ) {\n\n\t\t\tthis._task = renderTask.call( this );\n\n\t\t}\n\n\t\tthis._task.next();\n\n\t}\n\n}\n","import { NoBlending } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\n\nexport class BlendMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\ttarget1: { value: null },\n\t\t\t\ttarget2: { value: null },\n\t\t\t\topacity: { value: 1.0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { BufferGeometry } from 'three';\nimport { StaticGeometryGenerator, MeshBVH } from 'three-mesh-bvh';\nimport { setCommonAttributes, getGroupMaterialIndicesAttribute } from '../utils/GeometryPreparationUtils.js';\n\nexport class DynamicPathTracingSceneGenerator {\n\n\tget initialized() {\n\n\t\treturn Boolean( this.bvh );\n\n\t}\n\n\tconstructor( scene ) {\n\n\t\tthis.scene = scene;\n\t\tthis.bvh = null;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( scene );\n\n\t}\n\n\treset() {\n\n\t\tthis.bvh = null;\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.materials = null;\n\t\tthis.textures = null;\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.scene );\n\n\t}\n\n\tdispose() {}\n\n\tgenerate() {\n\n\t\tconst { scene, staticGeometryGenerator, geometry } = this;\n\t\tif ( this.bvh === null ) {\n\n\t\t\tconst attributes = [ 'position', 'normal', 'tangent', 'uv' ];\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst normalMapRequired = ! ! c.material.normalMap;\n\t\t\t\t\tsetCommonAttributes( c.geometry, { attributes, normalMapRequired } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst textureSet = new Set();\n\t\t\tconst materials = staticGeometryGenerator.getMaterials();\n\t\t\tmaterials.forEach( material => {\n\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\ttextureSet.add( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tstaticGeometryGenerator.attributes = attributes;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\n\t\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, materials, materials );\n\t\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\t\t\tgeometry.clearGroups();\n\n\t\t\tthis.bvh = new MeshBVH( geometry );\n\t\t\tthis.materials = materials;\n\t\t\tthis.textures = Array.from( textureSet );\n\n\t\t\treturn {\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tscene,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst { bvh } = this;\n\t\t\tstaticGeometryGenerator.generate( geometry );\n\t\t\tbvh.refit();\n\t\t\treturn {\n\t\t\t\tbvh: this.bvh,\n\t\t\t\tmaterials: this.materials,\n\t\t\t\ttextures: this.textures,\n\t\t\t\tscene,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\n}\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","import { PerspectiveCamera } from 'three';\n\nexport class PhysicalCamera extends PerspectiveCamera {\n\n\tset bokehSize( size ) {\n\n\t\tthis.fStop = this.getFocalLength() / size;\n\n\t}\n\n\tget bokehSize() {\n\n\t\treturn this.getFocalLength() / this.fStop;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.fStop = 1.4;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 25;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n}\n","import { Camera } from 'three';\n\nexport class EquirectCamera extends Camera {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isEquirectCamera = true;\n\n\t}\n\n}\n","import { WebGLRenderTarget, RGBAFormat, FloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport { shaderUtils } from '../shader/shaderUtils.js';\n\nclass PMREMCopyMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tblur: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ shaderUtils }\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class BlurredEnvMapGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: FloatType, format: RGBAFormat } );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.pmremGenerator.dispose();\n\t\tthis.copyQuad.dispose();\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\tgenerate( texture, blur ) {\n\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\n\n\t\t// get the pmrem target\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\n\n\t\t// set up the material\n\t\tconst { width, height } = texture.image;\n\t\trenderTarget.setSize( width, height );\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\n\t\tcopyQuad.material.blur = blur;\n\n\t\t// render\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\t\tcopyQuad.render( renderer );\n\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.autoClear = prevClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Float32Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, buffer );\n\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, FloatType );\n\t\tresult.minFilter = texture.minFilter;\n\t\tresult.magFilter = texture.magFilter;\n\t\tresult.wrapS = texture.wrapS;\n\t\tresult.wrapT = texture.wrapT;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\treturn result;\n\n\t}\n\n}\n","import { Matrix4, Matrix3, Color, Vector2 } from 'three';\nimport { MaterialBase } from './MaterialBase.js';\nimport {\n\tMeshBVHUniformStruct, FloatVertexAttributeTexture, UIntVertexAttributeTexture,\n\tshaderStructs, shaderIntersectFunction,\n} from 'three-mesh-bvh';\nimport { shaderMaterialStructs, shaderLightStruct } from '../shader/shaderStructs.js';\nimport { MaterialsTexture } from '../uniforms/MaterialsTexture.js';\nimport { RenderTarget2DArray } from '../uniforms/RenderTarget2DArray.js';\nimport { shaderMaterialSampling } from '../shader/shaderMaterialSampling.js';\nimport { shaderEnvMapSampling } from '../shader/shaderEnvMapSampling.js';\nimport { shaderLightSampling } from '../shader/shaderLightSampling.js';\nimport { shaderUtils } from '../shader/shaderUtils.js';\nimport { PhysicalCameraUniform } from '../uniforms/PhysicalCameraUniform.js';\nimport { EquirectHdrInfoUniform } from '../uniforms/EquirectHdrInfoUniform.js';\nimport { LightsTexture } from '../uniforms/LightsTexture.js';\n\nexport class PhysicalPathTracingMaterial extends MaterialBase {\n\n\tonBeforeRender() {\n\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t\tdefines: {\n\t\t\t\tFEATURE_MIS: 1,\n\t\t\t\tFEATURE_DOF: 1,\n\t\t\t\tFEATURE_GRADIENT_BG: 0,\n\t\t\t\tTRANSPARENT_TRAVERSALS: 5,\n\t\t\t\t// 0 = Perspective\n\t\t\t\t// 1 = Orthographic\n\t\t\t\t// 2 = Equirectangular\n\t\t\t\tCAMERA_TYPE: 0,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\tresolution: { value: new Vector2() },\n\n\t\t\t\tbounces: { value: 3 },\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\n\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tnormalAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\ttangentAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tuvAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\t\t\t\tlights: { value: new LightsTexture() },\n\t\t\t\tlightCount: { value: 0 },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\t\t\t\tbackgroundBlur: { value: 0.0 },\n\t\t\t\tenvironmentIntensity: { value: 2.0 },\n\t\t\t\tenvironmentRotation: { value: new Matrix3() },\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\n\n\t\t\t\tseed: { value: 0 },\n\t\t\t\topacity: { value: 1 },\n\t\t\t\tfilterGlossyFactor: { value: 0.0 },\n\n\t\t\t\tbgGradientTop: { value: new Color( 0x111111 ) },\n\t\t\t\tbgGradientBottom: { value: new Color( 0x000000 ) },\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t${ shaderStructs }\n\t\t\t\t${ shaderIntersectFunction }\n\t\t\t\t${ shaderMaterialStructs }\n\t\t\t\t${ shaderLightStruct }\n\n\t\t\t\t${ shaderUtils }\n\t\t\t\t${ shaderMaterialSampling }\n\t\t\t\t${ shaderEnvMapSampling }\n\t\t\t\t${ shaderLightSampling }\n\n\t\t\t\tuniform mat3 environmentRotation;\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\n\t\t\t\t#if FEATURE_GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n\t\t\t\tuniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform sampler2D normalAttribute;\n\t\t\t\tuniform sampler2D tangentAttribute;\n\t\t\t\tuniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float environmentIntensity;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2D lights;\n\t\t\t\tuniform uint lightCount;\n\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec3 sampleBackground( vec3 direction ) {\n\n\t\t\t\t\t#if FEATURE_GRADIENT_BG\n\n\t\t\t\t\tdirection = normalize( direction + randDirection() * 0.05 );\n\n\t\t\t\t\tfloat value = ( direction.y + 1.0 ) / 2.0;\n\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\treturn mix( bgGradientBottom, bgGradientTop, value );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + getHemisphereSample( direction, rand2() ) * 0.5 * backgroundBlur );\n\t\t\t\t\treturn environmentIntensity * sampleEquirectEnvMapColor( sampleDir, envMapInfo.map );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t\t\t\tbool attenuateHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, int traversals, bool isShadowRay, out vec3 color ) {\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\tcolor = vec3( 1.0 );\n\n\t\t\t\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\t\t\t\tif ( bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\t\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t\t// adjust the ray to the new surface\n\t\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Opacity Test\n\n\t\t\t\t\t\t\t// albedo\n\t\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// alphaMap\n\t\t\t\t\t\t\tif ( material.alphaMap != -1 ) {\n\n\t\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transmission\n\t\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// metalness\n\t\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttransmissionFactor < rand() && ! (\n\t\t\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\t\t\tmaterial.side != 0.0 && side == material.side\n\n\t\t\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// only attenuate on the way in\n\t\t\t\t\t\t\tif ( isBelowSurface ) {\n\n\t\t\t\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// returns whether the ray hit anything before a certain distance, not just the first surface. Could be optimized to not check the full hierarchy.\n\t\t\t\tbool anyCloserHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, float maxDist ) {\n\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\t\t\t\treturn hit && dist < maxDist;\n\n\t\t\t\t}\n\n\t\t\t\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t\t\t\t// erichlof/THREE.js-PathTracing-Renderer/\n\t\t\t\tfloat tentFilter( float x ) {\n\n\t\t\t\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t\t\t\t}\n\n\t\t\t\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\t\t\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\t\t\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t\t\t\t}\n\n\t\t\t\tvoid getCameraRay( out vec3 rayDirection, out vec3 rayOrigin ) {\n\n\t\t\t\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t\t\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t\t\t\t// around this pixel's UV coordinate\n\t\t\t\t\tvec2 jitteredUv = vUv + vec2( tentFilter( rand() ) * ssd.x, tentFilter( rand() ) * ssd.y );\n\n\t\t\t\t\t#if CAMERA_TYPE == 2\n\n\t\t\t\t\t\t// Equirectangular projection\n\n\t\t\t\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\t\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\t\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\t\t\t\trayDirection = normalize( rayDirection4.xyz );\n\t\t\t\t\t\trayOrigin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t// get [-1, 1] normalized device coordinates\n\t\t\t\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\n\t\t\t\t\t\trayOrigin = ndcToRayOrigin( ndc );\n\n\t\t\t\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t\t\t\t// Orthographic projection\n\n\t\t\t\t\t\t\trayDirection = ( cameraWorldMatrix * vec4( 0.0, 0.0, -1.0, 0.0 ) ).xyz;\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t// Perspective projection\n\n\t\t\t\t\t\t\trayDirection = normalize( mat3(cameraWorldMatrix) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if FEATURE_DOF\n\t\t\t\t\t{\n\n\t\t\t\t\t\t// depth of field\n\t\t\t\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\n\n\t\t\t\t\t\t// get the aperture sample\n\t\t\t\t\t\tvec2 apertureSample = sampleAperture( physicalCamera.apertureBlades ) * physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t\t\t\t// rotate the aperture shape\n\t\t\t\t\t\tfloat ac = cos( physicalCamera.apertureRotation );\n\t\t\t\t\t\tfloat as = sin( physicalCamera.apertureRotation );\n\t\t\t\t\t\tapertureSample = vec2(\n\t\t\t\t\t\t\tapertureSample.x * ac - apertureSample.y * as,\n\t\t\t\t\t\t\tapertureSample.x * as + apertureSample.y * ac\n\t\t\t\t\t\t);\n\t\t\t\t\t\tapertureSample.x *= saturate( physicalCamera.anamorphicRatio );\n\t\t\t\t\t\tapertureSample.y *= saturate( 1.0 / physicalCamera.anamorphicRatio );\n\n\t\t\t\t\t\t// create the new ray\n\t\t\t\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\t\t\t\trayDirection = focalPoint - rayOrigin;\n\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\trayDirection = normalize( rayDirection );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n\t\t\t\t\tvec3 rayDirection;\n\t\t\t\t\tvec3 rayOrigin;\n\n\t\t\t\t\tgetCameraRay( rayDirection, rayOrigin );\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tmat3 invEnvironmentRotation = inverse( environmentRotation );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t// hit results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\n\t\t\t\t\tfloat accumulatedClearcoatRoughness = 0.0;\n\t\t\t\t\tbool transmissiveRay = true;\n\t\t\t\t\tint transparentTraversals = TRANSPARENT_TRAVERSALS;\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\n\t\t\t\t\tSampleRec sampleRec;\n\t\t\t\t\tint i;\n\t\t\t\t\tbool isShadowRay = false;\n\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t\t\tLightSampleRec lightHit = lightsClosestHit( lights, lightCount, rayOrigin, rayDirection );\n\n\t\t\t\t\t\tif ( lightHit.hit && ( lightHit.dist < dist || !hit ) ) {\n\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, lightHit.pdf / float( lightCount + 1u ) );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tlightHit.emission *\n\t\t\t\t\t\t\t\t\tthroughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! hit ) {\n\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( environmentRotation * rayDirection ) * throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = envMapSample( environmentRotation * rayDirection, envMapInfo, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= float( lightCount + 1u );\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectEnvMapColor( environmentRotation * rayDirection, envMapInfo.map ) *\n\t\t\t\t\t\t\t\t\tthroughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\tif ( material.matte && i == 0 ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// alphaMap\n\t\t\t\t\t\tif ( material.alphaMap != -1 ) {\n\n\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t\t\t\t\t// and it's single sided.\n\t\t\t\t\t\t// - alpha test is disabled when it === 0\n\t\t\t\t\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t\t\t\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t\t\t\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\t\t\tbool isFirstHit = i == 0;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\t\tmaterial.side != 0.0 && ( side != material.side ) == isFirstHit\n\n\t\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( transparentTraversals );\n\t\t\t\t\t\t\ttransparentTraversals -= sign( transparentTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// fetch the interpolated smooth normal\n\t\t\t\t\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\t// roughness\n\t\t\t\t\t\tfloat roughness = material.roughness;\n\t\t\t\t\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// metalness\n\t\t\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transmission\n\t\t\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tvec3 baseNormal = normal;\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n\t\t\t\t\t\t// clearcoat\n\t\t\t\t\t\tfloat clearcoat = material.clearcoat;\n\t\t\t\t\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// clearcoat\n\t\t\t\t\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\t\t\t\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// clearcoatNormal\n\t\t\t\t\t\tvec3 clearcoatNormal = baseNormal;\n\t\t\t\t\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\t\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclearcoatNormal *= side;\n\n\t\t\t\t\t\tSurfaceRec surfaceRec;\n\t\t\t\t\t\tsurfaceRec.normal = normal;\n\t\t\t\t\t\tsurfaceRec.faceNormal = faceNormal;\n\t\t\t\t\t\tsurfaceRec.transmission = transmission;\n\t\t\t\t\t\tsurfaceRec.ior = material.ior;\n\t\t\t\t\t\tsurfaceRec.emission = emission;\n\t\t\t\t\t\tsurfaceRec.metalness = metalness;\n\t\t\t\t\t\tsurfaceRec.color = albedo.rgb;\n\t\t\t\t\t\tsurfaceRec.roughness = roughness;\n\t\t\t\t\t\tsurfaceRec.clearcoat = clearcoat;\n\t\t\t\t\t\tsurfaceRec.clearcoatRoughness = clearcoatRoughness;\n\n\t\t\t\t\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t\t\t\t\t// then we can just always assume this is a front face.\n\t\t\t\t\t\tsurfaceRec.frontFace = side == 1.0 || transmission == 0.0;\n\n\t\t\t\t\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t\t\t\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\t\t\t\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t\t\t\t\t// sharp internal reflections\n\t\t\t\t\t\tsurfaceRec.filteredRoughness = clamp( max( surfaceRec.roughness, accumulatedRoughness * filterGlossyFactor * 5.0 ), 0.0, 1.0 );\n\t\t\t\t\t\tsurfaceRec.filteredClearcoatRoughness = clamp( max( surfaceRec.clearcoatRoughness, accumulatedClearcoatRoughness * filterGlossyFactor * 5.0 ), 0.0, 1.0 );\n\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surfaceRec.normal );\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\n\n\t\t\t\t\t\tmat3 clearcoatNormalBasis = getBasisFromNormal( clearcoatNormal );\n\t\t\t\t\t\tmat3 clearcoatInvBasis = inverse( clearcoatNormalBasis );\n\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\n\t\t\t\t\t\tvec3 clearcoatOutgoing = - normalize( clearcoatInvBasis * rayDirection );\n\t\t\t\t\t\tsampleRec = bsdfSample( outgoing, clearcoatOutgoing, normalBasis, invBasis, clearcoatNormalBasis, clearcoatInvBasis, surfaceRec );\n\n\t\t\t\t\t\tisShadowRay = sampleRec.specularPdf < rand();\n\n\t\t\t\t\t\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t\t\t\t\t\t// maximum component-wise value of the current point to accommodate floating point\n\t\t\t\t\t\t// error as values increase.\n\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\tvec3 absPoint = abs( point );\n\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\n\n\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\n\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\n\n\t\t\t\t\t\t// direct env map sampling\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t// uniformly pick a light or environment map\n\t\t\t\t\t\tif( rand() > 1.0 / float( lightCount + 1u ) ) {\n\n\t\t\t\t\t\t\t// sample a light or environment\n\t\t\t\t\t\t\tLightSampleRec lightSampleRec = randomLightSample( lights, lightCount, rayOrigin );\n\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, lightSampleRec.direction ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tlightSampleRec.pdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the light area\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tlightSampleRec.pdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( lightSampleRec.direction, normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! anyCloserHit( bvh, rayOrigin, lightSampleRec.direction, lightSampleRec.dist )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat lightMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * lightSampleRec.direction ), normalize( clearcoatInvBasis * lightSampleRec.direction ), surfaceRec, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tfloat lightPdf = lightSampleRec.pdf / float( lightCount + 1u );\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\t\t\t\t\tvec3 envColor, envDirection;\n\t\t\t\t\t\t\tfloat envPdf = randomEnvMapSample( envMapInfo, envColor, envDirection );\n\t\t\t\t\t\t\tenvDirection = invEnvironmentRotation * envDirection;\n\n\t\t\t\t\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t\t\t\t\t// results so we ignore the sample in this case.\n\t\t\t\t\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, envDirection ) < 0.0;\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\t\t\t\t\tenvPdf = 0.0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check if a ray could even reach the surface\n\t\t\t\t\t\t\tvec3 attenuatedColor;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\t\t\t\t\tisDirectionValid( envDirection, normal, faceNormal ) &&\n\t\t\t\t\t\t\t\t! attenuateHit( bvh, rayOrigin, envDirection, bounces - i, isShadowRay, attenuatedColor )\n\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t// get the material pdf\n\t\t\t\t\t\t\t\tvec3 sampleColor;\n\t\t\t\t\t\t\t\tfloat envMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * envDirection ), normalize( clearcoatInvBasis * envDirection ), surfaceRec, sampleColor );\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\t\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\t\t\t\t\tenvPdf /= float( lightCount + 1u );\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += attenuatedColor * environmentIntensity * envColor * throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\tif ( ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\n\t\t\t\t\t\t\taccumulatedRoughness += sin( acosApprox( halfVector.z ) );\n\n\t\t\t\t\t\t\tvec3 clearcoatHalfVector = normalize( clearcoatOutgoing + sampleRec.clearcoatDirection );\n\t\t\t\t\t\t\taccumulatedClearcoatRoughness += sin( acosApprox( clearcoatHalfVector.z ) );\n\n\t\t\t\t\t\t\ttransmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate color\n\t\t\t\t\t\tgl_FragColor.rgb += ( emission * throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, normal, faceNormal) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\n\n\t\t\t\t\t\t// discard the sample if there are any NaNs\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide } from 'three';\n\nconst MATERIAL_PIXELS = 26;\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\n\nexport class MaterialsTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\n\n\t\tthis.format = RGBAFormat;\n\t\tthis.type = FloatType;\n\t\tthis.wrapS = ClampToEdgeWrapping;\n\t\tthis.wrapT = ClampToEdgeWrapping;\n\t\tthis.generateMipmaps = false;\n\t\tthis.threeCompatibilityTransforms = false;\n\n\t}\n\n\tsetCastShadow( materialIndex, cast ) {\n\n\t\t// invert the shadow value so we default to \"true\" when initializing a material\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 6 * 4 + 0;\n\t\tarray[ index ] = ! cast ? 1 : 0;\n\n\t}\n\n\tgetCastShadow( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 6 * 4 + 0;\n\t\treturn ! Boolean( array[ index ] );\n\n\t}\n\n\tsetSide( materialIndex, side ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 2;\n\t\tswitch ( side ) {\n\n\t\tcase FrontSide:\n\t\t\tarray[ index ] = 1;\n\t\t\tbreak;\n\t\tcase BackSide:\n\t\t\tarray[ index ] = - 1;\n\t\t\tbreak;\n\t\tcase DoubleSide:\n\t\t\tarray[ index ] = 0;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tgetSide( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 2;\n\t\tswitch ( array[ index ] ) {\n\n\t\tcase 0:\n\t\t\treturn DoubleSide;\n\t\tcase 1:\n\t\t\treturn FrontSide;\n\t\tcase - 1:\n\t\t\treturn BackSide;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\tsetMatte( materialIndex, matte ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 3;\n\t\tarray[ index ] = matte ? 1 : 0;\n\n\t}\n\n\tgetMatte( materialIndex ) {\n\n\t\tconst array = this.image.data;\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 3;\n\t\treturn Boolean( array[ index ] );\n\n\t}\n\n\tupdateFrom( materials, textures ) {\n\n\t\tfunction getTexture( material, key, def = - 1 ) {\n\n\t\t\treturn key in material ? textures.indexOf( material[ key ] ) : def;\n\n\t\t}\n\n\t\tfunction getField( material, key, def ) {\n\n\t\t\treturn key in material ? material[ key ] : def;\n\n\t\t}\n\n\t\tfunction getUVTransformTexture( material ) {\n\n\t\t\t// https://github.com/mrdoob/three.js/blob/f3a832e637c98a404c64dae8174625958455e038/src/renderers/webgl/WebGLMaterials.js#L204-L306\n\t\t\t// https://threejs.org/docs/#api/en/textures/Texture.offset\n\t\t\t// fallback order of textures to use as a common uv transform\n\t\t\treturn material.map ||\n\t\t\t\tmaterial.specularMap ||\n\t\t\t\tmaterial.displacementMap ||\n\t\t\t\tmaterial.normalMap ||\n\t\t\t\tmaterial.bumpMap ||\n\t\t\t\tmaterial.roughnessMap ||\n\t\t\t\tmaterial.metalnessMap ||\n\t\t\t\tmaterial.alphaMap ||\n\t\t\t\tmaterial.emissiveMap ||\n\t\t\t\tmaterial.clearcoatMap ||\n\t\t\t\tmaterial.clearcoatNormalMap ||\n\t\t\t\tmaterial.clearcoatRoughnessMap ||\n\t\t\t\tmaterial.iridescenceMap ||\n\t\t\t\tmaterial.iridescenceThicknessMap ||\n\t\t\t\tmaterial.specularIntensityMap ||\n\t\t\t\tmaterial.specularColorMap ||\n\t\t\t\tmaterial.transmissionMap ||\n\t\t\t\tmaterial.thicknessMap ||\n\t\t\t\tmaterial.sheenColorMap ||\n\t\t\t\tmaterial.sheenRoughnessMap ||\n\t\t\t\tnull;\n\n\t\t}\n\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\n\n\t\t\tlet texture;\n\t\t\tif ( threeCompatibilityTransforms ) {\n\n\t\t\t\ttexture = getUVTransformTexture( material );\n\n\t\t\t} else {\n\n\t\t\t\ttexture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\n\n\t\t\t}\n\n\t\t\t// check if texture exists\n\t\t\tif ( texture ) {\n\n\t\t\t\tconst elements = texture.matrix.elements;\n\n\t\t\t\tlet i = 0;\n\n\t\t\t\t// first row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\n\t\t\t\ti ++;\n\n\t\t\t\t// second row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn 8;\n\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\n\t\tconst { threeCompatibilityTransforms, image } = this;\n\n\t\tif ( image.width !== dimension ) {\n\n\t\t\tthis.dispose();\n\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\n\t\t\timage.width = dimension;\n\t\t\timage.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = image.data;\n\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n\t\t// can't encode texture ids that way.\n\t\t// const intArray = new Int32Array( floatArray.buffer );\n\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tconst m = materials[ i ];\n\n\t\t\t// color\n\t\t\tfloatArray[ index ++ ] = m.color.r;\n\t\t\tfloatArray[ index ++ ] = m.color.g;\n\t\t\tfloatArray[ index ++ ] = m.color.b;\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\n\n\t\t\t// metalness & roughness\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = textures.indexOf( m.metalnessMap );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = textures.indexOf( m.roughnessMap );\n\n\t\t\t// transmission & emissiveIntensity\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.0 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t// emission\n\t\t\tif ( 'emissive' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\n\n\t\t\t// normals\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\n\t\t\tif ( 'normalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\n\n \t\t\t} else {\n\n \t\t\t\tfloatArray[ index ++ ] = 1;\n \t\t\t\tfloatArray[ index ++ ] = 1;\n\n \t\t\t}\n\n\t\t\t// clearcoat\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' );\n\n\t\t\t// clearcoatRoughness\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\n\n\t\t\t// clearcoatNormal\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\n\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\n\t\t\t}\n\n\t\t\t// alphaMap\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\n\n\t\t\t// side & matte\n\t\t\tfloatArray[ index ++ ] = m.opacity;\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\n\t\t\tindex ++; // side\n\t\t\tindex ++; // matte\n\n\t\t\tindex ++; // shadow\n\n\t\t\t// map transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\n\n\t\t\t// metalnessMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\n\n\t\t\t// roughnessMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\n\n\t\t\t// transmissionMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\n\n\t\t\t// emissiveMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\n\n\t\t\t// normalMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\n\n\t\t\t// clearcoatMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\n\n\t\t\t// clearcoatNormalMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\n\n\t\t\t// clearcoatRoughnessMap transform\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n","import {\n\tWebGLArrayRenderTarget,\n\tRGBAFormat,\n\tUnsignedByteType,\n\tMeshBasicMaterial,\n\tColor,\n\tRepeatWrapping,\n\tLinearFilter,\n\tNoToneMapping,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nconst prevColor = new Color();\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconst tex = this.texture;\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = UnsignedByteType;\n\t\ttex.minFilter = LinearFilter;\n\t\ttex.magFilter = LinearFilter;\n\t\ttex.wrapS = RepeatWrapping;\n\t\ttex.wrapT = RepeatWrapping;\n\t\ttex.setTextures = ( ...args ) => {\n\n\t\t\tthis.setTextures( ...args );\n\n\t\t};\n\n\t\tconst fsQuad = new FullScreenQuad( new MeshBasicMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t}\n\n\tsetTextures( renderer, width, height, textures ) {\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target and ensure we don't have an empty texture\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\n\t\tconst depth = textures.length || 1;\n\t\tthis.setSize( width, height, depth );\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\t\t\tif ( texture ) {\n\n\t\t\t\t// revert to default texture transform before rendering\n\t\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\t\ttexture.matrix.identity();\n\n\t\t\t\tfsQuad.material.map = texture;\n\t\t\t\tfsQuad.material.transparent = true;\n\n\t\t\t\trenderer.setRenderTarget( this, i );\n\t\t\t\tfsQuad.render( renderer );\n\n\t\t\t\t// restore custom texture transform\n\t\t\t\ttexture.updateMatrix();\n\t\t\t\ttexture.matrixAutoUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n","import { shaderGGXFunctions } from './shaderGGXFunctions.js';\n\nexport const shaderMaterialSampling = /* glsl */`\n\nstruct SurfaceRec {\n\tvec3 normal;\n\tvec3 faceNormal;\n\tbool frontFace;\n\tfloat roughness;\n\tfloat filteredRoughness;\n\tfloat metalness;\n\tvec3 color;\n\tvec3 emission;\n\tfloat transmission;\n\tfloat ior;\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n\tfloat filteredClearcoatRoughness;\n};\n\nstruct SampleRec {\n\tfloat specularPdf;\n\tfloat pdf;\n\tvec3 direction;\n\tvec3 clearcoatDirection;\n\tvec3 color;\n};\n\n${ shaderGGXFunctions }\n\n// diffuse\nfloat diffusePDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tfloat cosValue = wi.z;\n\treturn cosValue / PI;\n\n}\n\nvec3 diffuseDirection( vec3 wo, SurfaceRec surf ) {\n\n\tvec3 lightDirection = randDirection();\n\tlightDirection.z += 1.0;\n\tlightDirection = normalize( lightDirection );\n\n\treturn lightDirection;\n\n}\n\nvec3 diffuseColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tfloat metalFactor = ( 1.0 - surf.metalness ) * wi.z / ( PI * PI );\n\tfloat transmissionFactor = 1.0 - surf.transmission;\n\treturn surf.color * metalFactor * transmissionFactor;\n\n}\n\n// specular\nfloat specularPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = getHalfVector( wi, wo );\n\treturn ggxPDF( wo, halfVector, filteredRoughness ) / ( 4.0 * dot( wi, halfVector ) );\n\n}\n\nvec3 specularDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredRoughness = surf.filteredRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\trand(),\n\t\trand()\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\nvec3 specularColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tfloat metalness = surf.metalness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat filteredRoughness = surf.filteredRoughness;\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tfloat D = ggxDistribution( halfVector, filteredRoughness );\n\n\tfloat F = schlickFresnelFromIor( dot( wi, halfVector ), iorRatio );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1.0;\n\n\t}\n\n\tvec3 color = mix( vec3( 1.0 ), surf.color, metalness );\n\tcolor = mix( color, vec3( 1.0 ), F );\n\tcolor *= G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\tcolor *= mix( F, 1.0, metalness );\n\tcolor *= wi.z; // scale the light by the direction the light is coming in from\n\n\treturn color;\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, surf ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfloat transmissionPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\n\n\tfloat roughness = surf.roughness;\n\tfloat ior = surf.ior;\n\tbool frontFace = surf.frontFace;\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\n\tvec3 lightDirection = refract( - wo, vec3( 0.0, 0.0, 1.0 ), ratio );\n\tlightDirection += randDirection() * roughness;\n\treturn normalize( lightDirection );\n\n}\n\nvec3 transmissionColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\n\tvec3 color = surf.color;\n\tcolor *= ( 1.0 - metalness );\n\tcolor *= transmission;\n\n\treturn color;\n\n}\n\n// clearcoat\nfloat clearcoatPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\tvec3 halfVector = getHalfVector( wi, wo );\n\treturn ggxPDF( wo, halfVector, filteredClearcoatRoughness ) / ( 4.0 * dot( wi, halfVector ) );\n\n}\n\nvec3 clearcoatDirection( vec3 wo, SurfaceRec surf ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\tvec3 halfVector = ggxDirection(\n\t\two,\n\t\tfilteredClearcoatRoughness,\n\t\tfilteredClearcoatRoughness,\n\t\trand(),\n\t\trand()\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\treturn - reflect( wo, halfVector );\n\n}\n\nvoid clearcoatColor( inout vec3 color, vec3 wo, vec3 wi, SurfaceRec surf ) {\n\n\tfloat ior = 1.5;\n\tbool frontFace = surf.frontFace;\n\tfloat filteredClearcoatRoughness = surf.filteredClearcoatRoughness;\n\n\tvec3 halfVector = getHalfVector( wo, wi );\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredClearcoatRoughness );\n\tfloat D = ggxDistribution( halfVector, filteredClearcoatRoughness );\n\n\tfloat F = schlickFresnelFromIor( dot( wi, halfVector ), ior );\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1.0;\n\n\t}\n\n\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\n\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n}\n\nvoid getLobeWeights( vec3 wo, vec3 clearcoatWo, SurfaceRec surf, out float diffuseWeight, out float specularWeight, out float transmissionWeight, out float clearcoatWeight ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat transSpecularProb = mix( reflectance, 1.0, metalness );\n\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb ) * ( 1.0 - clearcoatWeight );\n\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb * ( 1.0 - clearcoatWeight );\n\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb ) * ( 1.0 - clearcoatWeight );\n\n\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\tfloat invTotalWeight = 1.0 / totalWeight;\n\n\tdiffuseWeight *= invTotalWeight;\n\tspecularWeight *= invTotalWeight;\n\ttransmissionWeight *= invTotalWeight;\n\tclearcoatWeight *= invTotalWeight;\n\n}\n\nfloat bsdfPdf( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf, out float specularPdf, float diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight ) {\n\n\tfloat ior = surf.ior;\n\tfloat metalness = surf.metalness;\n\tfloat transmission = surf.transmission;\n\tbool frontFace = surf.frontFace;\n\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\n\tfloat cosTheta = min( wo.z, 1.0 );\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tbool cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1.0;\n\n\t}\n\n\tfloat spdf = 0.0;\n\tfloat dpdf = 0.0;\n\tfloat tpdf = 0.0;\n\tfloat cpdf = 0.0;\n\n\tif ( wi.z < 0.0 ) {\n\n\t\tif( transmissionWeight > 0.0 ) {\n\n\t\t\ttpdf = transmissionPDF( wo, wi, surf );\n\n\t\t}\n\n\t} else {\n\n\t\tif( diffuseWeight > 0.0 ) {\n\n\t\t\tdpdf = diffusePDF( wo, wi, surf );\n\n\t\t}\n\n\t\tif( specularWeight > 0.0 ) {\n\n\t\t\tspdf = specularPDF( wo, wi, surf );\n\n\t\t}\n\n\t}\n\n\tif( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\tcpdf = clearcoatPDF( clearcoatWo, clearcoatWi, surf );\n\n\t}\n\n\tfloat pdf =\n\t\t  dpdf * diffuseWeight\n\t\t+ spdf * specularWeight\n\t\t+ tpdf * transmissionWeight\n\t\t+ cpdf * clearcoatWeight;\n\n\t// retrieve specular rays for the shadows flag\n\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\treturn pdf;\n\n}\n\nvec3 bsdfColor( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf, float diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight ) {\n\n\tvec3 color = vec3( 0.0 );\n\tif ( wi.z < 0.0 ) {\n\n\t\tif( transmissionWeight > 0.0 ) {\n\n\t\t\tcolor = transmissionColor( wo, wi, surf );\n\n\t\t}\n\n\t} else {\n\n\t\tif( diffuseWeight > 0.0 ) {\n\n\t\t\tcolor = diffuseColor( wo, wi, surf );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\tif( specularWeight > 0.0 ) {\n\n\t\t\tcolor += specularColor( wo, wi, surf );\n\n\t\t}\n\n\t}\n\n\tif( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\tclearcoatColor( color, clearcoatWo, clearcoatWi, surf );\n\n\t}\n\n\treturn color;\n\n}\n\nfloat bsdfResult( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRec surf, out vec3 color ) {\n\n\tfloat diffuseWeight;\n\tfloat specularWeight;\n\tfloat transmissionWeight;\n\tfloat clearcoatWeight;\n\tgetLobeWeights( wo, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\tfloat specularPdf;\n\tcolor = bsdfColor( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\treturn bsdfPdf( wo, clearcoatWo, wi, clearcoatWi, surf, specularPdf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n}\n\nSampleRec bsdfSample( vec3 wo, vec3 clearcoatWo, mat3 normalBasis, mat3 invBasis, mat3 clearcoatNormalBasis, mat3 clearcoatInvBasis, SurfaceRec surf ) {\n\n\tfloat diffuseWeight;\n\tfloat specularWeight;\n\tfloat transmissionWeight;\n\tfloat clearcoatWeight;\n\tgetLobeWeights( wo, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\tfloat pdf[4];\n\tpdf[0] = diffuseWeight;\n\tpdf[1] = specularWeight;\n\tpdf[2] = transmissionWeight;\n\tpdf[3] = clearcoatWeight;\n\n\tfloat cdf[4];\n\tcdf[0] = pdf[0];\n\tcdf[1] = pdf[1] + cdf[0];\n\tcdf[2] = pdf[2] + cdf[1];\n\tcdf[3] = pdf[3] + cdf[2];\n\n\tif( cdf[3] != 0.0 ) {\n\n\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\tcdf[0] *= invMaxCdf;\n\t\tcdf[1] *= invMaxCdf;\n\t\tcdf[2] *= invMaxCdf;\n\t\tcdf[3] *= invMaxCdf;\n\n\t} else {\n\n\t\tcdf[0] = 1.0;\n\t\tcdf[1] = 0.0;\n\t\tcdf[2] = 0.0;\n\t\tcdf[3] = 0.0;\n\n\t}\n\n\tvec3 wi;\n\tvec3 clearcoatWi;\n\n\tfloat r = rand();\n\tif ( r <= cdf[0] ) {\n\n\t\twi = diffuseDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[1] ) {\n\n\t\twi = specularDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[2] ) {\n\n\t\twi = transmissionDirection( wo, surf );\n\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t} else if ( r <= cdf[3] ) {\n\n\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t}\n\n\tSampleRec result;\n\tresult.pdf = bsdfPdf( wo, clearcoatWo, wi, clearcoatWi, surf, result.specularPdf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\tresult.color = bsdfColor( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\tresult.direction = wi;\n\tresult.clearcoatDirection = clearcoatWi;\n\n\treturn result;\n\n}\n`;\n","export const shaderGGXFunctions = /* glsl */`\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\n// trowbridge-reitz === GGX === GTR\n\nvec3 ggxDirection( vec3 incidentDir, float roughnessX, float roughnessY, float random1, float random2 ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tvec3 V = normalize( vec3( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ) );\n\n\t// orthonormal basis\n\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\tvec3 T2 = cross( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tfloat a = 1.0 / ( 1.0 + V.z );\n\tfloat r = sqrt( random1 );\n\tfloat phi = ( random2 < a ) ? random2 / a * PI : PI + ( random2 - a ) / ( 1.0 - a ) * PI;\n\tfloat P1 = r * cos( phi );\n\tfloat P2 = r * sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t// unstretch\n\tN = normalize( vec3( roughnessX * N.x, roughnessY * N.y, max( 0.0, N.z ) ) );\n\n\treturn N;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfloat ggxLamda( float theta, float roughness ) {\n\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = tanTheta * tanTheta;\n\tfloat alpha2 = roughness * roughness;\n\n\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\treturn numerator / 2.0;\n\n}\n\n// See equation (2) from reference [2]\nfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat scatterTheta = acos( wo.z );\n\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t// See equation (33) from reference [0]\n\tfloat a2 = roughness * roughness;\n\ta2 = max( EPSILON, a2 );\n\tfloat cosTheta = halfVector.z;\n\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\tif ( cosTheta == 0.0 ) return 0.0;\n\n\tfloat theta = acosSafe( halfVector.z );\n\tfloat tanTheta = tan( theta );\n\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\treturn ( a2 / denom );\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\tfloat incidentTheta = acos( wi.z );\n\tfloat D = ggxDistribution( halfVector, roughness );\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n}\n`;\n","export const shaderEnvMapSampling = /* glsl */`\n\nvec3 sampleEquirectEnvMapColor( vec3 direction, sampler2D map ) {\n\n\treturn texture2D( map, equirectDirectionToUv( direction ) ).rgb;\n\n}\n\nfloat envMapDirectionPdf( vec3 direction ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tfloat theta = uv.y * PI;\n\tfloat sinTheta = sin( theta );\n\tif ( sinTheta == 0.0 ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n}\n\nfloat envMapSample( vec3 direction, EquirectHdrInfo info, out vec3 color ) {\n\n\tvec2 uv = equirectDirectionToUv( direction );\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\n\tfloat lum = colorToLuminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\nfloat randomEnvMapSample( EquirectHdrInfo info, out vec3 color, out vec3 direction ) {\n\n\t// sample env map cdf\n\tvec2 r = rand2();\n\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\n\tvec2 uv = vec2( u, v );\n\n\tvec3 derivedDirection = equirectUvToDirection( uv );\n\tdirection = derivedDirection;\n\tcolor = texture2D( info.map, uv ).rgb;\n\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\n\tfloat lum = colorToLuminance( color );\n\tivec2 resolution = textureSize( info.map, 0 );\n\tfloat pdf = lum / totalSum;\n\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\n\n}\n\n`;\n","export const shaderLightSampling = /* glsl */`\n\nstruct LightSampleRec {\n\tbool hit;\n\tfloat dist;\n\tvec3 direction;\n\tfloat pdf;\n\tvec3 emission;\n};\n\nLightSampleRec lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection ) {\n\n\tLightSampleRec lightSampleRec;\n\tlightSampleRec.hit = false;\n\n\tuint l;\n\tfor ( l = 0u; l < lightCount; l++ ) {\n\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\n\t\t// check for backface\n\t\tvec3 normal = normalize( cross( u, v ) );\n\t\tif ( dot( normal, rayDirection ) < 0.0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tu *= 1.0 / dot(u, u);\n\t\tv *= 1.0 / dot(v, v);\n\n\t\tfloat dist;\n\t\tif ( intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) {\n\n\t\t\tif ( dist < lightSampleRec.dist || !lightSampleRec.hit ) {\n\n\t\t\t\tlightSampleRec.hit = true;\n\t\t\t\tlightSampleRec.dist = dist;\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\tlightSampleRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\tlightSampleRec.emission = light.color * light.intensity;\n\t\t\t\tlightSampleRec.direction = rayDirection;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn lightSampleRec;\n\n}\n\nLightSampleRec randomRectAreaLightSample( Light light, vec3 rayOrigin ) {\n\n\tLightSampleRec lightSampleRec;\n\tlightSampleRec.hit = true;\n\n\tlightSampleRec.emission = light.color * light.intensity;\n\n\tvec3 randomPos = light.position + light.u * ( rand() - 0.5 ) + light.v * ( rand() - 0.5 );\n\tvec3 toLight = randomPos - rayOrigin;\n\tfloat lightDistSq = dot( toLight, toLight );\n\tlightSampleRec.dist = length( toLight );\n\n\tvec3 direction = normalize( toLight );\n\tlightSampleRec.direction = direction;\n\n\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\tlightSampleRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\treturn lightSampleRec;\n\n}\n\nLightSampleRec randomLightSample( sampler2D lights, uint lightCount, vec3 rayOrigin ) {\n\n\t// pick a random light\n\tuint l = uint( rand() * float( lightCount ) );\n\tLight light = readLightInfo( lights, l );\n\n\t// sample the light\n\treturn randomRectAreaLightSample( light, rayOrigin );\n\n}\n\n`;\n","import { PhysicalCamera } from '../core/PhysicalCamera.js';\nexport class PhysicalCameraUniform {\n\n\tconstructor() {\n\n\t\tthis.bokehSize = 0;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 10;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tupdateFrom( camera ) {\n\n\t\tif ( camera instanceof PhysicalCamera ) {\n\n\t\t\tthis.bokehSize = camera.bokehSize;\n\t\t\tthis.apertureBlades = camera.apertureBlades;\n\t\t\tthis.apertureRotation = camera.apertureRotation;\n\t\t\tthis.focusDistance = camera.focusDistance;\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\n\n\t\t} else {\n\n\t\t\tthis.bokehSize = 0;\n\t\t\tthis.apertureRotation = 0;\n\t\t\tthis.apertureBlades = 0;\n\t\t\tthis.focusDistance = 10;\n\t\t\tthis.anamorphicRatio = 1;\n\n\t\t}\n\n\t}\n\n}\n","import { DataTexture, FloatType, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping } from 'three';\n\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\n\n\tlet lower = 0;\n\tlet upper = count;\n\twhile ( lower < upper ) {\n\n\t\tconst mid = ~ ~ ( 0.5 * upper + 0.5 * lower );\n\n\n\t\t// check if the middle array value is above or below the target and shift\n\t\t// which half of the array we're looking at\n\t\tif ( array[ offset + mid ] < targetValue ) {\n\n\t\t\tlower = mid + 1;\n\n\t\t} else {\n\n\t\t\tupper = mid;\n\n\t\t}\n\n\t}\n\n\treturn lower;\n\n}\n\nfunction colorToLuminance( r, g, b ) {\n\n\t// https://en.wikipedia.org/wiki/Relative_luminance\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\n}\n\n// ensures the data is all floating point values and flipY is false\nfunction preprocessEnvMap( envMap ) {\n\n\tconst map = envMap.clone();\n\tmap.source = new Source( { ...map.image } );\n\tconst { width, height, data } = map.image;\n\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\n\tlet newData = data;\n\tif ( map.type === HalfFloatType ) {\n\n\t\tnewData = new Float32Array( data.length );\n\t\tfor ( const i in data ) {\n\n\t\t\tnewData[ i ] = DataUtils.fromHalfFloat( data[ i ] );\n\n\t\t}\n\n\t\tmap.image.data = newData;\n\t\tmap.type = FloatType;\n\n\t}\n\n\t// remove any y flipping for cdf computation\n\tif ( map.flipY ) {\n\n\t\tconst ogData = newData;\n\t\tnewData = newData.slice();\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst newY = height - y - 1;\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\n\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tmap.flipY = false;\n\t\tmap.image.data = newData;\n\n\t}\n\n\treturn map;\n\n}\n\nexport class EquirectHdrInfoUniform {\n\n\tconstructor() {\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\n\t\t// used to sampling a random value to a relevant row to sample from\n\t\tconst marginalWeights = new DataTexture();\n\t\tmarginalWeights.type = FloatType;\n\t\tmarginalWeights.format = RedFormat;\n\t\tmarginalWeights.minFilter = LinearFilter;\n\t\tmarginalWeights.magFilter = LinearFilter;\n\t\tmarginalWeights.generateMipmaps = false;\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\n\t\t// used to sampling a random value to a relevant pixel to sample from\n\t\tconst conditionalWeights = new DataTexture();\n\t\tconditionalWeights.type = FloatType;\n\t\tconditionalWeights.format = RedFormat;\n\t\tconditionalWeights.minFilter = LinearFilter;\n\t\tconditionalWeights.magFilter = LinearFilter;\n\t\tconditionalWeights.generateMipmaps = false;\n\n\t\t// store the total sum in a 1x1 tex since some android mobile devices have issues\n\t\t// storing large values in structs.\n\t\tconst totalSumTex = new DataTexture();\n\t\ttotalSumTex.type = FloatType;\n\t\ttotalSumTex.format = RedFormat;\n\t\ttotalSumTex.minFilter = LinearFilter;\n\t\ttotalSumTex.magFilter = LinearFilter;\n\t\ttotalSumTex.generateMipmaps = false;\n\n\t\tthis.marginalWeights = marginalWeights;\n\t\tthis.conditionalWeights = conditionalWeights;\n\t\tthis.totalSum = totalSumTex;\n\t\tthis.map = null;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.marginalWeights.dispose();\n\t\tthis.conditionalWeights.dispose();\n\t\tthis.totalSum.dispose();\n\t\tif ( this.map ) this.map.dispose();\n\n\t}\n\n\tupdateFrom( hdr ) {\n\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\n\t\tconst map = preprocessEnvMap( hdr );\n\t\tmap.wrapS = RepeatWrapping;\n\t\tmap.wrapT = RepeatWrapping;\n\n\t\tconst { width, height, data } = map.image;\n\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\n\t\t// \"marginal\" = \"row relative to row sum\"\n\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\n\t\tconst pdfConditional = new Float32Array( width * height );\n\t\tconst cdfConditional = new Float32Array( width * height );\n\n\t\tconst pdfMarginal = new Float32Array( height );\n\t\tconst cdfMarginal = new Float32Array( height );\n\n\t\tlet totalSumValue = 0.0;\n\t\tlet cumulativeWeightMarginal = 0.0;\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tlet cumulativeRowWeight = 0.0;\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst r = data[ 4 * i + 0 ];\n\t\t\t\tconst g = data[ 4 * i + 1 ];\n\t\t\t\tconst b = data[ 4 * i + 2 ];\n\n\t\t\t\t// the probability of the pixel being selected in this row is the\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\n\t\t\t\tcumulativeRowWeight += weight;\n\t\t\t\ttotalSumValue += weight;\n\n\t\t\t\tpdfConditional[ i ] = weight;\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\n\n\t\t\t}\n\n\t\t\t// can happen if the row is all black\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\n\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\n\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\n\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\n\n\t\t}\n\n\t\t// can happen if the texture is all black\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\n\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\n\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute a sorted index of distributions and the probabilities along them for both\n\t\t// the marginal and conditional data. These will be used to sample with a random number\n\t\t// to retrieve a uv value to sample in the environment map.\n\t\t// These values continually increase so it's okay to interpolate between them.\n\t\tconst marginalDataArray = new Float32Array( height );\n\t\tconst conditionalDataArray = new Float32Array( width * height );\n\n\t\tfor ( let i = 0; i < height; i ++ ) {\n\n\t\t\tconst dist = ( i + 1 ) / height;\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\n\n\t\t\tmarginalDataArray[ i ] = row / height;\n\n\t\t}\n\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst dist = ( x + 1 ) / width;\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\n\n\t\t\t\tconditionalDataArray[ i ] = col / width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispose();\n\n\t\tconst { marginalWeights, conditionalWeights, totalSum } = this;\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\n\t\tmarginalWeights.needsUpdate = true;\n\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\n\t\tconditionalWeights.needsUpdate = true;\n\n\t\ttotalSum.image = { width: 1, height: 1, data: new Float32Array( [ totalSumValue ] ) };\n\t\ttotalSum.needsUpdate = true;\n\n\t\tthis.map = map;\n\n\t}\n\n}\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion } from 'three';\n\nconst LIGHT_PIXELS = 4;\n\nexport class LightsTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\n\n\t\tthis.format = RGBAFormat;\n\t\tthis.type = FloatType;\n\t\tthis.wrapS = ClampToEdgeWrapping;\n\t\tthis.wrapT = ClampToEdgeWrapping;\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tupdateFrom( lights ) {\n\n\t\tlet index = 0;\n\t\tconst pixelCount = lights.length * LIGHT_PIXELS;\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\n\n\t\tif ( this.image.width !== dimension ) {\n\n\t\t\tthis.dispose();\n\n\t\t\tthis.image.data = new Float32Array( dimension * dimension * 4 );\n\t\t\tthis.image.width = dimension;\n\t\t\tthis.image.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = this.image.data;\n\n\t\tconst u = new Vector3();\n\t\tconst v = new Vector3();\n\t\tconst worldQuaternion = new Quaternion();\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst l = lights[ i ];\n\n\t\t\t// position\n\t\t\tl.getWorldPosition( v );\n\t\t\tfloatArray[ index ++ ] = v.x;\n\t\t\tfloatArray[ index ++ ] = v.y;\n\t\t\tfloatArray[ index ++ ] = v.z;\n\t\t\tindex ++;\n\n\t\t\t// color\n\t\t\tfloatArray[ index ++ ] = l.color.r;\n\t\t\tfloatArray[ index ++ ] = l.color.g;\n\t\t\tfloatArray[ index ++ ] = l.color.b;\n\n\t\t\t// intensity\n\t\t\tfloatArray[ index ++ ] = l.intensity;\n\n\t\t\t// u vector\n\t\t\tl.getWorldQuaternion( worldQuaternion );\n\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\n\t\t\tfloatArray[ index ++ ] = u.x;\n\t\t\tfloatArray[ index ++ ] = u.y;\n\t\t\tfloatArray[ index ++ ] = u.z;\n\t\t\tindex ++;\n\n\t\t\t// v vector\n\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\n\t\t\tfloatArray[ index ++ ] = v.x;\n\t\t\tfloatArray[ index ++ ] = v.y;\n\t\t\tfloatArray[ index ++ ] = v.z;\n\n\t\t\t// area\n\t\t\tfloatArray[ index ++ ] = u.cross( v ).length();\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n"],"names":["$ilwiq","parcelRequire","$5ee05658f4b0e3bf$export$d076a711b55c758a","DataTextureLoader","constructor","manager","super","this","type","HalfFloatType","parse","buffer1","rgbe_error","rgbe_error_code","msg","console","error","fgets","buffer","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","Math","pow","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","byteArray","Uint8Array","rgbe_header_info","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","line","match","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","count","ptr","isEncodedRun","byteValue","set","l","off","RGBE_ReadPixels_RLE","data","numElements","FloatType","floatArray","Float32Array","j","halfArray","j1","setDataType","value","load","url","onLoad","onProgress","onError","texture","texData","encoding","LinearEncoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","$d0f249dd9f03ac59$var$renderTask","_renderer","_fsQuad","_blendQuad","_primaryTarget","_blendTargets","alpha","camera","material","blendMaterial","blendTarget1","blendTarget2","opacity","samples","blending","NoBlending","NormalBlending","resolution","seed","tx","tiles","x","ty","y","totalTiles","dprInv","getPixelRatio","cameraWorldMatrix","copy","matrixWorld","invProjectionMatrix","projectionMatrixInverse","cameraType","projectionMatrix","elements","isEquirectCamera","setDefine","ogRenderTarget","getRenderTarget","ogAutoClear","autoClear","setRenderTarget","setScissorTest","setScissor","ceil","render","target1","target2","round","$d0f249dd9f03ac59$var$ogClearColor","Color","$d0f249dd9f03ac59$export$196da6cc71a4331","v","target","_alpha","dispose","reset","renderer","Vector2","stableNoise","$RPVlj","FullScreenQuad","$2JSgM","BlendMaterial","_task","WebGLRenderTarget","RGBAFormat","setSize","ogClearAlpha","getClearAlpha","getClearColor","setClearColor","clearColor","update","call","next","$1fe9e194dadaa0ff$export$70ee8b3cbd6f21d8","$9fZ6X","MaterialBase","parameters","uniforms","vertexShader","fragmentShader","setValues","$fc1143d2ee906d9d$export$b42762e2bf679e84","initialized","Boolean","bvh","scene","geometry","BufferGeometry","materials","textures","staticGeometryGenerator","$8Zfx2","StaticGeometryGenerator","generate","attributes","traverse","c","isMesh","normalMapRequired","normalMap","$jM3IF","setCommonAttributes","textureSet","Set","getMaterials","forEach","key","isTexture","add","materialIndexAttribute","getGroupMaterialIndicesAttribute","setAttribute","clearGroups","MeshBVH","Array","from","refit","$465cbee6efe1dae1$var$isTypedArray","arr","ArrayBuffer","$465cbee6efe1dae1$export$c80603c061964928","ignoreKeys","shareTextures","areEqual","objectA","objectB","keySet","traverseSet","a","b","Object","has","Error","aIsElement","Element","bIsElement","Image","src","aIsImageBitmap","ImageBitmap","bIsImageBitmap","equals","aIsTypedArray","bIsTypedArray","clear","hasOwnProperty","Function","key1","keys","values","result","delete","process","object","replaced","processMaterial","foundMaterial","otherMaterial","push","image","foundTexture","isArray","retained","$911d375abf1afdea$export$baf85f88dacad6d5","PerspectiveCamera","bokehSize","size","fStop","getFocalLength","args","apertureBlades","apertureRotation","focusDistance","anamorphicRatio","$1168068d45013e8b$export$6503f7c8e24ae98b","Camera","$ac13547279de9cd0$var$PMREMCopyMaterial","envMap","blur","$jNhCl","shaderUtils","$ac13547279de9cd0$export$13ef63fd7e562136","pmremGenerator","PMREMGenerator","copyQuad","renderTarget","pmremTarget","fromEquirectangular","prevRenderTarget","prevClear","readRenderTargetPixels","DataTexture","wrapS","wrapT","mapping","EquirectangularReflectionMapping","needsUpdate","$6b5ea45f30e12757$export$746cbc9e65f5bcb8","onBeforeRender","physicalCamera","transparent","depthWrite","defines","FEATURE_MIS","FEATURE_DOF","FEATURE_GRADIENT_BG","TRANSPARENT_TRAVERSALS","CAMERA_TYPE","bounces","$iyhQ7","PhysicalCameraUniform","MeshBVHUniformStruct","normalAttribute","FloatVertexAttributeTexture","tangentAttribute","uvAttribute","UIntVertexAttributeTexture","$laA5G","MaterialsTexture","$12pjC","RenderTarget2DArray","lights","$jNveS","LightsTexture","lightCount","Matrix4","backgroundBlur","environmentIntensity","environmentRotation","Matrix3","envMapInfo","$kAJM1","EquirectHdrInfoUniform","filterGlossyFactor","bgGradientTop","bgGradientBottom","backgroundAlpha","shaderStructs","shaderIntersectFunction","$5Wq6T","shaderMaterialStructs","shaderLightStruct","$fcAdp","shaderMaterialSampling","$1RTaa","shaderEnvMapSampling","$22srR","shaderLightSampling","$f69686fae5159582$var$MATERIAL_STRIDE","$f69686fae5159582$var$MATERIAL_PIXELS","$f69686fae5159582$export$ae96f3619813ce17","ClampToEdgeWrapping","threeCompatibilityTransforms","setCastShadow","materialIndex","cast","getCastShadow","array","setSide","side","index","FrontSide","BackSide","DoubleSide","getSide","setMatte","matte","getMatte","updateFrom","getTexture","def","getField","writeTextureMatrixToArray","textureKey","map","specularMap","displacementMap","bumpMap","roughnessMap","metalnessMap","alphaMap","emissiveMap","clearcoatMap","clearcoatNormalMap","clearcoatRoughnessMap","iridescenceMap","iridescenceThicknessMap","specularIntensityMap","specularColorMap","transmissionMap","thicknessMap","sheenColorMap","sheenRoughnessMap","getUVTransformTexture","matrix","pixelCount","dimension","sqrt","i1","m","color","r","g","emissive","normalScale","clearcoatNormalScale","alphaTest","$0c199d70d276a61d$var$prevColor","$0c199d70d276a61d$export$dbbaa51cb2d0b2f7","WebGLArrayRenderTarget","args1","tex","UnsignedByteType","RepeatWrapping","setTextures","fsQuad","MeshBasicMaterial","prevToneMapping","toneMapping","prevAlpha","depth","NoToneMapping","matrixAutoUpdate","identity","updateMatrix","$b114119888481524$export$aba3482f45fc2e55","shaderGGXFunctions","$8456ef8cb9b1d3a5$export$75d2a701aae03ef9","$15c587eb667da097$export$c4e96847515c3dca","$17c1d5e781a3625a$export$72ea2c7ee2a3cb14","$csrdQ","$d8193d8a8d6141d1$export$2e27c77dea3c9d73","PhysicalCamera","$efdaad16b8cd905b$var$binarySearchFindClosestIndexOf","targetValue","lower","upper","mid","$efdaad16b8cd905b$var$colorToLuminance","$efdaad16b8cd905b$export$e5a77e5d6a85a862","marginalWeights","RedFormat","conditionalWeights","totalSumTex","totalSum","hdr","clone","source","Source","newData","fromHalfFloat","ogData","ogIndex","newIndex","$efdaad16b8cd905b$var$preprocessEnvMap","pdfConditional","cdfConditional","pdfMarginal","cdfMarginal","totalSumValue","cumulativeWeightMarginal","cumulativeRowWeight","weight","marginalDataArray","conditionalDataArray","row","y1","col","$e69ad350c877a240$export$4104d5d95c9a0783","u","Vector3","worldQuaternion","Quaternion","getWorldPosition","z","intensity","getWorldQuaternion","applyQuaternion","cross"],"version":3,"file":"amato.dd0c4e17.js.map"}